// Do not edit: This code was generated by flatdata's generator.
/// OSM data types and archive
pub mod osm {

    #[doc(hidden)]
    pub mod schema {
        pub mod structs {
            pub const HEADER: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

"#;
            pub const TAG: &str = r#"namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

"#;
            pub const NODE: &str = r#"namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

"#;
            pub const NODE_INDEX: &str = r#"namespace osm {
struct NodeIndex
{
    value : u64 : 40;
}
}

"#;
            pub const WAY: &str = r#"namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

"#;
            pub const TAG_INDEX: &str = r#"namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

"#;
            pub const NODE_MEMBER: &str = r#"namespace osm {
struct NodeMember
{
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

"#;
            pub const WAY_MEMBER: &str = r#"namespace osm {
struct WayMember
{
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

"#;
            pub const RELATION_MEMBER: &str = r#"namespace osm {
struct RelationMember
{
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

"#;
            pub const RELATION: &str = r#"namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

"#;
        }

        pub mod osm {

            pub const OSM: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
struct NodeMember
{
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct WayMember
{
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct RelationMember
{
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

namespace osm {
struct NodeIndex
{
    value : u64 : 40;
}
}

namespace osm {
const u64 INVALID_IDX = 1099511627775;
}

namespace osm {
const u64 COORD_SCALE = 1000000000;
}

namespace osm {
@bound_implicitly( Relations : .osm.Osm.relations, .osm.Osm.relation_members )
archive Osm
{
    @explicit_reference( .osm.Header.required_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.optional_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.writingprogram_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.source_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.osmosis_replication_base_url_idx, .osm.Osm.stringtable )
    header : .osm.Header;
    @explicit_reference( .osm.Node.tag_first_idx, .osm.Osm.tags_index )
    nodes : vector< .osm.Node >;
    @explicit_reference( .osm.Way.tag_first_idx, .osm.Osm.tags_index )
    @explicit_reference( .osm.Way.ref_first_idx, .osm.Osm.nodes_index )
    ways : vector< .osm.Way >;
    @explicit_reference( .osm.Relation.tag_first_idx, .osm.Osm.tags_index )
    relations : vector< .osm.Relation >;
    @explicit_reference( .osm.NodeMember.node_idx, .osm.Osm.nodes )
    @explicit_reference( .osm.NodeMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.WayMember.way_idx, .osm.Osm.ways )
    @explicit_reference( .osm.WayMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.RelationMember.relation_idx, .osm.Osm.relations )
    @explicit_reference( .osm.RelationMember.role_idx, .osm.Osm.stringtable )
    relation_members : multivector< 40, .osm.NodeMember, .osm.WayMember, .osm.RelationMember >;
    @explicit_reference( .osm.Tag.key_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Tag.value_idx, .osm.Osm.stringtable )
    tags : vector< .osm.Tag >;
    @explicit_reference( .osm.TagIndex.value, .osm.Osm.tags )
    tags_index : vector< .osm.TagIndex >;
    @explicit_reference( .osm.NodeIndex.value, .osm.Osm.nodes )
    nodes_index : vector< .osm.NodeIndex >;
    stringtable : raw_data;
}
}

"#;

            pub mod resources {
                pub const HEADER: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Header.required_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.optional_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.writingprogram_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.source_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.osmosis_replication_base_url_idx, .osm.Osm.stringtable )
    header : .osm.Header;
}
}

"#;
                pub const NODES: &str = r#"namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Node.tag_first_idx, .osm.Osm.tags_index )
    nodes : vector< .osm.Node >;
}
}

"#;
                pub const WAYS: &str = r#"namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Way.tag_first_idx, .osm.Osm.tags_index )
    @explicit_reference( .osm.Way.ref_first_idx, .osm.Osm.nodes_index )
    ways : vector< .osm.Way >;
}
}

"#;
                pub const RELATIONS: &str = r#"namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Relation.tag_first_idx, .osm.Osm.tags_index )
    relations : vector< .osm.Relation >;
}
}

"#;
                pub const RELATION_MEMBERS: &str = r#"namespace osm {
struct NodeMember
{
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct WayMember
{
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct RelationMember
{
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.NodeMember.node_idx, .osm.Osm.nodes )
    @explicit_reference( .osm.NodeMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.WayMember.way_idx, .osm.Osm.ways )
    @explicit_reference( .osm.WayMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.RelationMember.relation_idx, .osm.Osm.relations )
    @explicit_reference( .osm.RelationMember.role_idx, .osm.Osm.stringtable )
    relation_members : multivector< 40, .osm.NodeMember, .osm.WayMember, .osm.RelationMember >;
}
}

"#;
                pub const TAGS: &str = r#"namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Tag.key_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Tag.value_idx, .osm.Osm.stringtable )
    tags : vector< .osm.Tag >;
}
}

"#;
                pub const TAGS_INDEX: &str = r#"namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.TagIndex.value, .osm.Osm.tags )
    tags_index : vector< .osm.TagIndex >;
}
}

"#;
                pub const NODES_INDEX: &str = r#"namespace osm {
struct NodeIndex
{
    value : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.NodeIndex.value, .osm.Osm.nodes )
    nodes_index : vector< .osm.NodeIndex >;
}
}

"#;
                pub const STRINGTABLE: &str = r#"namespace osm {
archive Osm
{
    stringtable : raw_data;
}
}

"#;
            }
        }
    }
    /// Special value which represents an invalid index.
    pub const INVALID_IDX: u64 = 1_099_511_627_775;

    /// All coordinate are scaled by this constant to convert them to integers.
    pub const COORD_SCALE: u64 = 1_000_000_000;

    /// Metadata attached to the archive.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`HeaderRef`] for the read-only access, and
    /// * [`HeaderMut`] for the mutable access
    ///
    /// to the `Header` data.
    ///
    /// [`HeaderRef`]: struct.HeaderRef.html
    /// [`HeaderMut`]: struct.HeaderMut.html
    #[derive(Clone, Debug)]
    pub struct Header {}

    /// Read-only access to [`Header`].
    ///
    /// [`Header`]: struct.Header.html
    #[derive(Clone, Copy)]
    pub struct HeaderRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for Header {
        const SCHEMA: &'static str = schema::structs::HEADER;
        const SIZE_IN_BYTES: usize = 62;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = HeaderRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = HeaderMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for Header {}

    impl<'a> HeaderRef<'a> {
        /// Bounding box (min longitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_left(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Bounding box (max longitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_right(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 40, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Bounding box (max latitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_top(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 80, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Bounding box (min latitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_bottom(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 120, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Reference to the first required feature in `stringtable`.
        #[inline]
        pub fn required_feature_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 160, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Number of required features.
        #[inline]
        pub fn required_features_size(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 200, 4);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        /// Reference to the first optional feature in `stringtable`.
        #[inline]
        pub fn optional_feature_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 204, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Number of optional features.
        #[inline]
        pub fn optional_features_size(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 244, 4);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        /// Writing program used to write the data (reference to `stringtable`).
        #[inline]
        pub fn writingprogram_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 248, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// The origin (source) of the data.
        #[inline]
        pub fn source_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 288, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Replication timestamp, expressed in seconds since the epoch.
        /// See [`state.txt`].
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        pub fn osmosis_replication_timestamp(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 328, 64);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Replication sequence number (`sequenceNumber` from [`state.txt`]).
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        pub fn osmosis_replication_sequence_number(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 392, 64);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Replication base URL (reference to `stringtable`).
        #[inline]
        pub fn osmosis_replication_base_url_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 456, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for HeaderRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Header")
                .field("bbox_left", &self.bbox_left())
                .field("bbox_right", &self.bbox_right())
                .field("bbox_top", &self.bbox_top())
                .field("bbox_bottom", &self.bbox_bottom())
                .field(
                    "required_feature_first_idx",
                    &self.required_feature_first_idx(),
                )
                .field("required_features_size", &self.required_features_size())
                .field(
                    "optional_feature_first_idx",
                    &self.optional_feature_first_idx(),
                )
                .field("optional_features_size", &self.optional_features_size())
                .field("writingprogram_idx", &self.writingprogram_idx())
                .field("source_idx", &self.source_idx())
                .field(
                    "osmosis_replication_timestamp",
                    &self.osmosis_replication_timestamp(),
                )
                .field(
                    "osmosis_replication_sequence_number",
                    &self.osmosis_replication_sequence_number(),
                )
                .field(
                    "osmosis_replication_base_url_idx",
                    &self.osmosis_replication_base_url_idx(),
                )
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for HeaderRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.bbox_left() == other.bbox_left()
                && self.bbox_right() == other.bbox_right()
                && self.bbox_top() == other.bbox_top()
                && self.bbox_bottom() == other.bbox_bottom()
                && self.required_feature_first_idx() == other.required_feature_first_idx()
                && self.required_features_size() == other.required_features_size()
                && self.optional_feature_first_idx() == other.optional_feature_first_idx()
                && self.optional_features_size() == other.optional_features_size()
                && self.writingprogram_idx() == other.writingprogram_idx()
                && self.source_idx() == other.source_idx()
                && self.osmosis_replication_timestamp() == other.osmosis_replication_timestamp()
                && self.osmosis_replication_sequence_number()
                    == other.osmosis_replication_sequence_number()
                && self.osmosis_replication_base_url_idx()
                    == other.osmosis_replication_base_url_idx()
        }
    }

    impl<'a> flatdata::Ref for HeaderRef<'a> {}

    /// Mutable access to [`Header`].
    ///
    /// [`Header`]: struct.Header.html
    pub struct HeaderMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> HeaderMut<'a> {
        /// Bounding box (min longitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_left(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_bbox_left(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(i64; value, buffer, 0, 40)
        }

        /// Bounding box (max longitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_right(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 40, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_bbox_right(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(i64; value, buffer, 40, 40)
        }

        /// Bounding box (max latitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_top(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 80, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_bbox_top(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(i64; value, buffer, 80, 40)
        }

        /// Bounding box (min latitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_bottom(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 120, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_bbox_bottom(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(i64; value, buffer, 120, 40)
        }

        /// Reference to the first required feature in `stringtable`.
        #[inline]
        pub fn required_feature_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 160, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_required_feature_first_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u64; value, buffer, 160, 40)
        }

        /// Number of required features.
        #[inline]
        pub fn required_features_size(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 200, 4);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_required_features_size(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u32; value, buffer, 200, 4)
        }

        /// Reference to the first optional feature in `stringtable`.
        #[inline]
        pub fn optional_feature_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 204, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_optional_feature_first_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u64; value, buffer, 204, 40)
        }

        /// Number of optional features.
        #[inline]
        pub fn optional_features_size(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 244, 4);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_optional_features_size(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u32; value, buffer, 244, 4)
        }

        /// Writing program used to write the data (reference to `stringtable`).
        #[inline]
        pub fn writingprogram_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 248, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_writingprogram_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u64; value, buffer, 248, 40)
        }

        /// The origin (source) of the data.
        #[inline]
        pub fn source_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 288, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_source_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u64; value, buffer, 288, 40)
        }

        /// Replication timestamp, expressed in seconds since the epoch.
        /// See [`state.txt`].
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        pub fn osmosis_replication_timestamp(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 328, 64);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_osmosis_replication_timestamp(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(i64; value, buffer, 328, 64)
        }

        /// Replication sequence number (`sequenceNumber` from [`state.txt`]).
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        pub fn osmosis_replication_sequence_number(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 392, 64);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_osmosis_replication_sequence_number(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(i64; value, buffer, 392, 64)
        }

        /// Replication base URL (reference to `stringtable`).
        #[inline]
        pub fn osmosis_replication_base_url_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 456, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_osmosis_replication_base_url_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 62) };
            flatdata_write_bytes!(u64; value, buffer, 456, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &HeaderRef) {
            self.set_bbox_left(other.bbox_left());
            self.set_bbox_right(other.bbox_right());
            self.set_bbox_top(other.bbox_top());
            self.set_bbox_bottom(other.bbox_bottom());
            self.set_required_feature_first_idx(other.required_feature_first_idx());
            self.set_required_features_size(other.required_features_size());
            self.set_optional_feature_first_idx(other.optional_feature_first_idx());
            self.set_optional_features_size(other.optional_features_size());
            self.set_writingprogram_idx(other.writingprogram_idx());
            self.set_source_idx(other.source_idx());
            self.set_osmosis_replication_timestamp(other.osmosis_replication_timestamp());
            self.set_osmosis_replication_sequence_number(
                other.osmosis_replication_sequence_number(),
            );
            self.set_osmosis_replication_base_url_idx(other.osmosis_replication_base_url_idx());
        }
    }

    impl<'a> std::fmt::Debug for HeaderMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            HeaderRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for HeaderMut<'a> {}

    /// A `(key, value)` attached to a `Node`, `Way`, or `Relation.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`TagRef`] for the read-only access, and
    /// * [`TagMut`] for the mutable access
    ///
    /// to the `Tag` data.
    ///
    /// [`TagRef`]: struct.TagRef.html
    /// [`TagMut`]: struct.TagMut.html
    #[derive(Clone, Debug)]
    pub struct Tag {}

    /// Read-only access to [`Tag`].
    ///
    /// [`Tag`]: struct.Tag.html
    #[derive(Clone, Copy)]
    pub struct TagRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for Tag {
        const SCHEMA: &'static str = schema::structs::TAG;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = TagRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = TagMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for Tag {}

    impl<'a> TagRef<'a> {
        /// Key index in `stringtable`
        #[inline]
        pub fn key_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Value index in `stringtable`
        #[inline]
        pub fn value_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for TagRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Tag")
                .field("key_idx", &self.key_idx())
                .field("value_idx", &self.value_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for TagRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.key_idx() == other.key_idx() && self.value_idx() == other.value_idx()
        }
    }

    impl<'a> flatdata::Ref for TagRef<'a> {}

    /// Mutable access to [`Tag`].
    ///
    /// [`Tag`]: struct.Tag.html
    pub struct TagMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> TagMut<'a> {
        /// Key index in `stringtable`
        #[inline]
        pub fn key_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_key_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 0, 40)
        }

        /// Value index in `stringtable`
        #[inline]
        pub fn value_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_value_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &TagRef) {
            self.set_key_idx(other.key_idx());
            self.set_value_idx(other.value_idx());
        }
    }

    impl<'a> std::fmt::Debug for TagMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            TagRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for TagMut<'a> {}

    /// A node is one of the core elements in the OpenStreetMap data model.
    ///
    /// It consists of a single point in space defined by its latitude, longitude and node id.
    ///
    /// See <https://wiki.openstreetmap.org/wiki/Node>.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`NodeRef`] for the read-only access, and
    /// * [`NodeMut`] for the mutable access
    ///
    /// to the `Node` data.
    ///
    /// [`NodeRef`]: struct.NodeRef.html
    /// [`NodeMut`]: struct.NodeMut.html
    #[derive(Clone, Debug)]
    pub struct Node {}

    /// Read-only access to [`Node`].
    ///
    /// [`Node`]: struct.Node.html
    #[derive(Clone, Copy)]
    pub struct NodeRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for Node {
        const SCHEMA: &'static str = schema::structs::NODE;
        const SIZE_IN_BYTES: usize = 20;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;

        type Item = NodeRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = NodeMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl<'a> NodeRef<'a> {
        /// Unique node ID
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Latitude (scaled with `COORD_SCALE`).
        #[inline]
        pub fn lat(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 40, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Longitude (scaled with `COORD_SCALE`).
        #[inline]
        pub fn lon(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 80, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: #method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 120, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of tags attached to this node.
        ///
        /// The values of the range are indexes in the `tags_index` vector.
        #[inline]
        pub fn tags(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data, 120, 40);
            let end = flatdata_read_bytes!(u64, self.data, 120 + 20 * 8, 40);
            start..end
        }
    }

    impl<'a> std::fmt::Debug for NodeRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Node")
                .field("id", &self.id())
                .field("lat", &self.lat())
                .field("lon", &self.lon())
                .field("tag_first_idx", &self.tag_first_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for NodeRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.id() == other.id()
                && self.lat() == other.lat()
                && self.lon() == other.lon()
                && self.tag_first_idx() == other.tag_first_idx()
        }
    }

    impl<'a> flatdata::Ref for NodeRef<'a> {}

    /// Mutable access to [`Node`].
    ///
    /// [`Node`]: struct.Node.html
    pub struct NodeMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> NodeMut<'a> {
        /// Unique node ID
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_id(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 20) };
            flatdata_write_bytes!(i64; value, buffer, 0, 40)
        }

        /// Latitude (scaled with `COORD_SCALE`).
        #[inline]
        pub fn lat(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 40, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_lat(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 20) };
            flatdata_write_bytes!(i64; value, buffer, 40, 40)
        }

        /// Longitude (scaled with `COORD_SCALE`).
        #[inline]
        pub fn lon(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 80, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_lon(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 20) };
            flatdata_write_bytes!(i64; value, buffer, 80, 40)
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: struct.NodeRef.html#method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 120, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_tag_first_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 20) };
            flatdata_write_bytes!(u64; value, buffer, 120, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &NodeRef) {
            self.set_id(other.id());
            self.set_lat(other.lat());
            self.set_lon(other.lon());
            self.set_tag_first_idx(other.tag_first_idx());
        }
    }

    impl<'a> std::fmt::Debug for NodeMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            NodeRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for NodeMut<'a> {}

    /// Index of a node.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`NodeIndexRef`] for the read-only access, and
    /// * [`NodeIndexMut`] for the mutable access
    ///
    /// to the `NodeIndex` data.
    ///
    /// [`NodeIndexRef`]: struct.NodeIndexRef.html
    /// [`NodeIndexMut`]: struct.NodeIndexMut.html
    #[derive(Clone, Debug)]
    pub struct NodeIndex {}

    /// Read-only access to [`NodeIndex`].
    ///
    /// [`NodeIndex`]: struct.NodeIndex.html
    #[derive(Clone, Copy)]
    pub struct NodeIndexRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for NodeIndex {
        const SCHEMA: &'static str = schema::structs::NODE_INDEX;
        const SIZE_IN_BYTES: usize = 5;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = NodeIndexRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = NodeIndexMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for NodeIndex {}

    impl<'a> NodeIndexRef<'a> {
        /// Index in the `nodes` vector.
        #[inline]
        pub fn value(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for NodeIndexRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("NodeIndex")
                .field("value", &self.value())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for NodeIndexRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.value() == other.value()
        }
    }

    impl<'a> flatdata::Ref for NodeIndexRef<'a> {}

    /// Mutable access to [`NodeIndex`].
    ///
    /// [`NodeIndex`]: struct.NodeIndex.html
    pub struct NodeIndexMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> NodeIndexMut<'a> {
        /// Index in the `nodes` vector.
        #[inline]
        pub fn value(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_value(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 5) };
            flatdata_write_bytes!(u64; value, buffer, 0, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &NodeIndexRef) {
            self.set_value(other.value());
        }
    }

    impl<'a> std::fmt::Debug for NodeIndexMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            NodeIndexRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for NodeIndexMut<'a> {}

    /// A way is an ordered list of nodes.
    ///
    /// See https://wiki.openstreetmap.org/wiki/Way.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`WayRef`] for the read-only access, and
    /// * [`WayMut`] for the mutable access
    ///
    /// to the `Way` data.
    ///
    /// [`WayRef`]: struct.WayRef.html
    /// [`WayMut`]: struct.WayMut.html
    #[derive(Clone, Debug)]
    pub struct Way {}

    /// Read-only access to [`Way`].
    ///
    /// [`Way`]: struct.Way.html
    #[derive(Clone, Copy)]
    pub struct WayRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for Way {
        const SCHEMA: &'static str = schema::structs::WAY;
        const SIZE_IN_BYTES: usize = 15;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;

        type Item = WayRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = WayMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl<'a> WayRef<'a> {
        /// Unique ID of the way.
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: #method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of tags attached to this node.
        ///
        /// The values of the range are indexes in the `tags_index` vector.
        #[inline]
        pub fn tags(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data, 40, 40);
            let end = flatdata_read_bytes!(u64, self.data, 40 + 15 * 8, 40);
            start..end
        }

        /// First element of the range [`refs`].
        ///
        /// [`refs`]: #method.refs
        #[inline]
        pub fn ref_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 80, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of nodes this way consists of.
        ///
        /// The values of the range are indexes in the `nodes_index` vector.
        #[inline]
        pub fn refs(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data, 80, 40);
            let end = flatdata_read_bytes!(u64, self.data, 80 + 15 * 8, 40);
            start..end
        }
    }

    impl<'a> std::fmt::Debug for WayRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Way")
                .field("id", &self.id())
                .field("tag_first_idx", &self.tag_first_idx())
                .field("ref_first_idx", &self.ref_first_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for WayRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.id() == other.id()
                && self.tag_first_idx() == other.tag_first_idx()
                && self.ref_first_idx() == other.ref_first_idx()
        }
    }

    impl<'a> flatdata::Ref for WayRef<'a> {}

    /// Mutable access to [`Way`].
    ///
    /// [`Way`]: struct.Way.html
    pub struct WayMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> WayMut<'a> {
        /// Unique ID of the way.
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_id(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 15) };
            flatdata_write_bytes!(i64; value, buffer, 0, 40)
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: struct.WayRef.html#method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_tag_first_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 15) };
            flatdata_write_bytes!(u64; value, buffer, 40, 40)
        }

        /// First element of the range [`refs`].
        ///
        /// [`refs`]: struct.WayRef.html#method.refs
        #[inline]
        pub fn ref_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 80, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_ref_first_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 15) };
            flatdata_write_bytes!(u64; value, buffer, 80, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &WayRef) {
            self.set_id(other.id());
            self.set_tag_first_idx(other.tag_first_idx());
            self.set_ref_first_idx(other.ref_first_idx());
        }
    }

    impl<'a> std::fmt::Debug for WayMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            WayRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for WayMut<'a> {}

    /// Index of a tag.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`TagIndexRef`] for the read-only access, and
    /// * [`TagIndexMut`] for the mutable access
    ///
    /// to the `TagIndex` data.
    ///
    /// [`TagIndexRef`]: struct.TagIndexRef.html
    /// [`TagIndexMut`]: struct.TagIndexMut.html
    #[derive(Clone, Debug)]
    pub struct TagIndex {}

    /// Read-only access to [`TagIndex`].
    ///
    /// [`TagIndex`]: struct.TagIndex.html
    #[derive(Clone, Copy)]
    pub struct TagIndexRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for TagIndex {
        const SCHEMA: &'static str = schema::structs::TAG_INDEX;
        const SIZE_IN_BYTES: usize = 5;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = TagIndexRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = TagIndexMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for TagIndex {}

    impl<'a> TagIndexRef<'a> {
        /// Index in the `tags` vector.
        #[inline]
        pub fn value(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for TagIndexRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("TagIndex")
                .field("value", &self.value())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for TagIndexRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.value() == other.value()
        }
    }

    impl<'a> flatdata::Ref for TagIndexRef<'a> {}

    /// Mutable access to [`TagIndex`].
    ///
    /// [`TagIndex`]: struct.TagIndex.html
    pub struct TagIndexMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> TagIndexMut<'a> {
        /// Index in the `tags` vector.
        #[inline]
        pub fn value(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_value(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 5) };
            flatdata_write_bytes!(u64; value, buffer, 0, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &TagIndexRef) {
            self.set_value(other.value());
        }
    }

    impl<'a> std::fmt::Debug for TagIndexMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            TagIndexRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for TagIndexMut<'a> {}

    /// Node member of a relation.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`NodeMemberRef`] for the read-only access, and
    /// * [`NodeMemberMut`] for the mutable access
    ///
    /// to the `NodeMember` data.
    ///
    /// [`NodeMemberRef`]: struct.NodeMemberRef.html
    /// [`NodeMemberMut`]: struct.NodeMemberMut.html
    #[derive(Clone, Debug)]
    pub struct NodeMember {}

    /// Read-only access to [`NodeMember`].
    ///
    /// [`NodeMember`]: struct.NodeMember.html
    #[derive(Clone, Copy)]
    pub struct NodeMemberRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for NodeMember {
        const SCHEMA: &'static str = schema::structs::NODE_MEMBER;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = NodeMemberRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = NodeMemberMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for NodeMember {}

    impl<'a> NodeMemberRef<'a> {
        /// Index of the node in the `nodes` vector.
        #[inline]
        pub fn node_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Optional textual field describing the function of the node in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for NodeMemberRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("NodeMember")
                .field("node_idx", &self.node_idx())
                .field("role_idx", &self.role_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for NodeMemberRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.node_idx() == other.node_idx() && self.role_idx() == other.role_idx()
        }
    }

    impl<'a> flatdata::Ref for NodeMemberRef<'a> {}

    /// Mutable access to [`NodeMember`].
    ///
    /// [`NodeMember`]: struct.NodeMember.html
    pub struct NodeMemberMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> NodeMemberMut<'a> {
        /// Index of the node in the `nodes` vector.
        #[inline]
        pub fn node_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_node_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 0, 40)
        }

        /// Optional textual field describing the function of the node in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_role_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &NodeMemberRef) {
            self.set_node_idx(other.node_idx());
            self.set_role_idx(other.role_idx());
        }
    }

    impl<'a> std::fmt::Debug for NodeMemberMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            NodeMemberRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for NodeMemberMut<'a> {}

    /// Way member of a relation.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`WayMemberRef`] for the read-only access, and
    /// * [`WayMemberMut`] for the mutable access
    ///
    /// to the `WayMember` data.
    ///
    /// [`WayMemberRef`]: struct.WayMemberRef.html
    /// [`WayMemberMut`]: struct.WayMemberMut.html
    #[derive(Clone, Debug)]
    pub struct WayMember {}

    /// Read-only access to [`WayMember`].
    ///
    /// [`WayMember`]: struct.WayMember.html
    #[derive(Clone, Copy)]
    pub struct WayMemberRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for WayMember {
        const SCHEMA: &'static str = schema::structs::WAY_MEMBER;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = WayMemberRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = WayMemberMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for WayMember {}

    impl<'a> WayMemberRef<'a> {
        /// Index of the way in the `ways` vector.
        #[inline]
        pub fn way_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Optional textual field describing the function of the way in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for WayMemberRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("WayMember")
                .field("way_idx", &self.way_idx())
                .field("role_idx", &self.role_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for WayMemberRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.way_idx() == other.way_idx() && self.role_idx() == other.role_idx()
        }
    }

    impl<'a> flatdata::Ref for WayMemberRef<'a> {}

    /// Mutable access to [`WayMember`].
    ///
    /// [`WayMember`]: struct.WayMember.html
    pub struct WayMemberMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> WayMemberMut<'a> {
        /// Index of the way in the `ways` vector.
        #[inline]
        pub fn way_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_way_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 0, 40)
        }

        /// Optional textual field describing the function of the way in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_role_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &WayMemberRef) {
            self.set_way_idx(other.way_idx());
            self.set_role_idx(other.role_idx());
        }
    }

    impl<'a> std::fmt::Debug for WayMemberMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            WayMemberRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for WayMemberMut<'a> {}

    /// Relation member of a relation.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`RelationMemberRef`] for the read-only access, and
    /// * [`RelationMemberMut`] for the mutable access
    ///
    /// to the `RelationMember` data.
    ///
    /// [`RelationMemberRef`]: struct.RelationMemberRef.html
    /// [`RelationMemberMut`]: struct.RelationMemberMut.html
    #[derive(Clone, Debug)]
    pub struct RelationMember {}

    /// Read-only access to [`RelationMember`].
    ///
    /// [`RelationMember`]: struct.RelationMember.html
    #[derive(Clone, Copy)]
    pub struct RelationMemberRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for RelationMember {
        const SCHEMA: &'static str = schema::structs::RELATION_MEMBER;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = RelationMemberRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = RelationMemberMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl flatdata::NoOverlap for RelationMember {}

    impl<'a> RelationMemberRef<'a> {
        /// Index of the relation in the `relations` vector.
        #[inline]
        pub fn relation_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Optional textual field describing the function of the relation in the parent relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl<'a> std::fmt::Debug for RelationMemberRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("RelationMember")
                .field("relation_idx", &self.relation_idx())
                .field("role_idx", &self.role_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for RelationMemberRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.relation_idx() == other.relation_idx() && self.role_idx() == other.role_idx()
        }
    }

    impl<'a> flatdata::Ref for RelationMemberRef<'a> {}

    /// Mutable access to [`RelationMember`].
    ///
    /// [`RelationMember`]: struct.RelationMember.html
    pub struct RelationMemberMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> RelationMemberMut<'a> {
        /// Index of the relation in the `relations` vector.
        #[inline]
        pub fn relation_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_relation_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 0, 40)
        }

        /// Optional textual field describing the function of the relation in the parent relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_role_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &RelationMemberRef) {
            self.set_relation_idx(other.relation_idx());
            self.set_role_idx(other.role_idx());
        }
    }

    impl<'a> std::fmt::Debug for RelationMemberMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            RelationMemberRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for RelationMemberMut<'a> {}

    /// A relation is an ordered list of one or more nodes, ways and/or relations as members.
    ///
    /// See https://wiki.openstreetmap.org/wiki/Relation.
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in containers.
    /// It does not contain any data, instead it references
    ///
    /// * [`RelationRef`] for the read-only access, and
    /// * [`RelationMut`] for the mutable access
    ///
    /// to the `Relation` data.
    ///
    /// [`RelationRef`]: struct.RelationRef.html
    /// [`RelationMut`]: struct.RelationMut.html
    #[derive(Clone, Debug)]
    pub struct Relation {}

    /// Read-only access to [`Relation`].
    ///
    /// [`Relation`]: struct.Relation.html
    #[derive(Clone, Copy)]
    pub struct RelationRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> flatdata::Struct<'a> for Relation {
        const SCHEMA: &'static str = schema::structs::RELATION;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;

        type Item = RelationRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = RelationMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl<'a> RelationRef<'a> {
        /// Unique ID of the relation.
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: #method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of tags attached to this relation.
        ///
        /// The values of the range are indexes in the `tags` vector.
        #[inline]
        pub fn tags(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data, 40, 40);
            let end = flatdata_read_bytes!(u64, self.data, 40 + 10 * 8, 40);
            start..end
        }
    }

    impl<'a> std::fmt::Debug for RelationRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Relation")
                .field("id", &self.id())
                .field("tag_first_idx", &self.tag_first_idx())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for RelationRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.id() == other.id() && self.tag_first_idx() == other.tag_first_idx()
        }
    }

    impl<'a> flatdata::Ref for RelationRef<'a> {}

    /// Mutable access to [`Relation`].
    ///
    /// [`Relation`]: struct.Relation.html
    pub struct RelationMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> RelationMut<'a> {
        /// Unique ID of the relation.
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data, 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_id(&mut self, value: i64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(i64; value, buffer, 0, 40)
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: struct.RelationRef.html#method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data, 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        #[allow(missing_docs)]
        #[inline]
        pub fn set_tag_first_idx(&mut self, value: u64) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 10) };
            flatdata_write_bytes!(u64; value, buffer, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &RelationRef) {
            self.set_id(other.id());
            self.set_tag_first_idx(other.tag_first_idx());
        }
    }

    impl<'a> std::fmt::Debug for RelationMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            RelationRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> flatdata::RefMut for RelationMut<'a> {}

    /// Enum for read-only heterogeneous access to elements in a
    /// bucket of the [`relation_members`] resource.
    ///
    /// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
    #[derive(Clone, PartialEq)]
    pub enum RelationMembersRef<'a> {
        #[allow(missing_docs)]
        NodeMember(<super::osm::NodeMember as flatdata::Struct<'a>>::Item),
        #[allow(missing_docs)]
        WayMember(<super::osm::WayMember as flatdata::Struct<'a>>::Item),
        #[allow(missing_docs)]
        RelationMember(<super::osm::RelationMember as flatdata::Struct<'a>>::Item),
    }

    impl<'a> ::std::fmt::Debug for RelationMembersRef<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                RelationMembersRef::NodeMember(ref inner) => write!(f, "{:?}", inner),
                RelationMembersRef::WayMember(ref inner) => write!(f, "{:?}", inner),
                RelationMembersRef::RelationMember(ref inner) => write!(f, "{:?}", inner),
            }
        }
    }

    impl<'a> flatdata::VariadicRef for RelationMembersRef<'a> {
        #[inline]
        fn size_in_bytes(&self) -> usize {
            match *self {
                RelationMembersRef::NodeMember(_) => {
                    <super::osm::NodeMember as flatdata::Struct<'a>>::SIZE_IN_BYTES
                }
                RelationMembersRef::WayMember(_) => {
                    <super::osm::WayMember as flatdata::Struct<'a>>::SIZE_IN_BYTES
                }
                RelationMembersRef::RelationMember(_) => {
                    <super::osm::RelationMember as flatdata::Struct<'a>>::SIZE_IN_BYTES
                }
            }
        }
    }

    /// Builder of buckets in the [`relation_members`] resource.
    ///
    /// Refers to a single bucket in the [`relation_members`] multivector and
    /// provides methods for adding heterogeneous data to the bucket.
    ///
    /// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
    pub struct RelationMembersBuilder<'a> {
        data: &'a mut Vec<u8>,
    }

    impl<'a> RelationMembersBuilder<'a> {
        /// Adds data of the type [`NodeMember`] to the bucket.
        ///
        /// [`NodeMember`]: struct.NodeMember.html
        #[inline]
        pub fn add_node_member<'b>(
            &'b mut self,
        ) -> <super::osm::NodeMember as flatdata::Struct<'b>>::ItemMut {
            let old_len = self.data.len();
            let increment = 1 + <super::osm::NodeMember as flatdata::Struct<'b>>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len - flatdata::PADDING_SIZE] = 0;
            <super::osm::NodeMember as flatdata::Struct<'b>>::create_mut(
                &mut self.data[1 + old_len - flatdata::PADDING_SIZE..],
            )
        }
        /// Adds data of the type [`WayMember`] to the bucket.
        ///
        /// [`WayMember`]: struct.WayMember.html
        #[inline]
        pub fn add_way_member<'b>(
            &'b mut self,
        ) -> <super::osm::WayMember as flatdata::Struct<'b>>::ItemMut {
            let old_len = self.data.len();
            let increment = 1 + <super::osm::WayMember as flatdata::Struct<'b>>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len - flatdata::PADDING_SIZE] = 1;
            <super::osm::WayMember as flatdata::Struct<'b>>::create_mut(
                &mut self.data[1 + old_len - flatdata::PADDING_SIZE..],
            )
        }
        /// Adds data of the type [`RelationMember`] to the bucket.
        ///
        /// [`RelationMember`]: struct.RelationMember.html
        #[inline]
        pub fn add_relation_member<'b>(
            &'b mut self,
        ) -> <super::osm::RelationMember as flatdata::Struct<'b>>::ItemMut {
            let old_len = self.data.len();
            let increment = 1 + <super::osm::RelationMember as flatdata::Struct<'b>>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len - flatdata::PADDING_SIZE] = 2;
            <super::osm::RelationMember as flatdata::Struct<'b>>::create_mut(
                &mut self.data[1 + old_len - flatdata::PADDING_SIZE..],
            )
        }
    }

    /// Variadic struct attached to the [`relation_members`] archive resource.
    ///
    /// It unifies the following data types:
    //
    /// * [`NodeMember`]
    /// * [`WayMember`]
    /// * [`RelationMember`]
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in [`relation_members`] multivector/
    /// multiarray view. It does not contain any data, instead it references
    ///
    /// * [`RelationMembersRef`] for the read-only heterogeneous access, and
    /// * [`RelationMembersBuilder`] for the mutable builder pattern access.
    ///
    /// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
    /// [`RelationMembersRef`]: enum.RelationMembersRef.html
    /// [`RelationMembersBuilder`]: struct.RelationMembersBuilder.html
    /// [`NodeMember`]: struct.NodeMember.html
    /// [`WayMember`]: struct.WayMember.html
    /// [`RelationMember`]: struct.RelationMember.html
    #[derive(Clone)]
    pub struct RelationMembers {}

    impl<'a> flatdata::VariadicStruct<'a> for RelationMembers {
        type Index = super::_builtin::multivector::IndexType40;

        type Item = RelationMembersRef<'a>;

        #[inline]
        fn create(index: flatdata::TypeIndex, data: &'a [u8]) -> Self::Item {
            match index {
                0 => RelationMembersRef::NodeMember(<super::osm::NodeMember as flatdata::Struct<
                    'a,
                >>::create(data)),
                1 => RelationMembersRef::WayMember(<super::osm::WayMember as flatdata::Struct<
                    'a,
                >>::create(data)),
                2 => RelationMembersRef::RelationMember(
                    <super::osm::RelationMember as flatdata::Struct<'a>>::create(data),
                ),
                _ => panic!(
                    "invalid type index {} for variadic type RelationMembersRef",
                    index
                ),
            }
        }

        type ItemMut = RelationMembersBuilder<'a>;

        #[inline]
        fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut {
            Self::ItemMut { data }
        }
    }

    /// OSM data archive
    ///
    /// Relations and relation members are indexed with the same index, i.e.
    /// a relation at index `i` in the vector `relations` has the members
    /// at index `i` in the multivector `relation_members`.
    ///
    /// All 1:n relationships are modeled in-place by using an additional index. This is a
    /// common pattern in flatdata. For example, a node might have multiple tags attached
    /// to it. To model this, a node in `nodes` references the first tag attached to it
    /// by storing an index in the `tags_index` vector. The next node in `nodes` again
    /// references its first tag, which is the last tag (exclusive) of the previous node.
    ///
    /// ```text
    /// nodes:      [ ..., n_1, n_2, ... ]
    ///                     |    |
    ///                     |    +-------+
    ///                     v            v
    /// tags_index: [ ..., t_11, t_12, ..., t_1n, t_21, ... t_2m, ... ]
    /// ```
    #[derive(Clone)]
    pub struct Osm {
        _storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
        header: flatdata::MemoryDescriptor,
        nodes: flatdata::MemoryDescriptor,
        ways: flatdata::MemoryDescriptor,
        relations: flatdata::MemoryDescriptor,
        relation_members: (flatdata::MemoryDescriptor, flatdata::MemoryDescriptor),
        tags: flatdata::MemoryDescriptor,
        tags_index: flatdata::MemoryDescriptor,
        nodes_index: flatdata::MemoryDescriptor,
        stringtable: flatdata::MemoryDescriptor,
    }

    impl Osm {
        fn read_resource(
            storage: &dyn flatdata::ResourceStorage,
            name: &str,
            schema: &str,
        ) -> Result<flatdata::MemoryDescriptor, flatdata::ResourceStorageError> {
            storage
                .read(name, schema)
                .map(|x| flatdata::MemoryDescriptor::new(&x))
        }

        fn signature_name(archive_name: &str) -> String {
            format!("{}.archive", archive_name)
        }

        /// Header which contains the metadata attached to the archive.
        #[inline]
        pub fn header(&self) -> <super::osm::Header as flatdata::Struct>::Item {
            <super::osm::Header as flatdata::Struct>::create(&unsafe { self.header.as_bytes() })
        }

        /// List of nodes.
        ///
        /// A node references a range of tags in the `tags_index` vector.
        #[inline]
        pub fn nodes(&self) -> flatdata::ArrayView<super::osm::Node> {
            flatdata::ArrayView::new(&unsafe { self.nodes.as_bytes() })
        }

        /// List of ways.
        ///
        /// A way references
        ///
        /// * a range of tags in the `tags_index` vector, and
        /// * a range of nodes in the `nodes_index` vector.
        #[inline]
        pub fn ways(&self) -> flatdata::ArrayView<super::osm::Way> {
            flatdata::ArrayView::new(&unsafe { self.ways.as_bytes() })
        }

        /// List of relations.
        ///
        /// A relation references a range of tags in `tags_index` vectors.
        /// Members are attached to a relation implicitly: members that belong to a
        /// relation at index `i` are at index `i` in the `relation_members` multivector.
        #[inline]
        pub fn relations(&self) -> flatdata::ArrayView<super::osm::Relation> {
            flatdata::ArrayView::new(&unsafe { self.relations.as_bytes() })
        }

        /// Members attached to relations.
        ///
        /// An index in this multivector corresponds to an index in the `relations` vector.
        ///
        /// A member has a variadic type: `NodeMember`, `WayMember` or `RelationMember`.
        /// Each type references its role in the `stringtable` raw data. Additionally,
        ///
        /// * a node member references a node in the `nodes` vector,
        /// * a way member references a way in the `ways` vector,
        /// * a relation member references a relation in the `relations` vector.
        #[inline]
        pub fn relation_members(&self) -> flatdata::MultiArrayView<RelationMembers> {
            flatdata::MultiArrayView::new(
                flatdata::ArrayView::new(&unsafe { self.relation_members.0.as_bytes() }),
                &unsafe { self.relation_members.1.as_bytes() },
            )
        }

        /// List of tags.
        ///
        /// A tag references its key and value in the `stringtable` raw data.
        #[inline]
        pub fn tags(&self) -> flatdata::ArrayView<super::osm::Tag> {
            flatdata::ArrayView::new(&unsafe { self.tags.as_bytes() })
        }

        /// Auxiliary index of tags to model 1:n relationships between nodes, ways, relations
        /// and tags.
        #[inline]
        pub fn tags_index(&self) -> flatdata::ArrayView<super::osm::TagIndex> {
            flatdata::ArrayView::new(&unsafe { self.tags_index.as_bytes() })
        }

        /// Auxiliary index of nodes to model 1:n relationship between ways and nodes.
        #[inline]
        pub fn nodes_index(&self) -> flatdata::ArrayView<super::osm::NodeIndex> {
            flatdata::ArrayView::new(&unsafe { self.nodes_index.as_bytes() })
        }

        /// List of strings separated by `\0`.
        #[inline]
        pub fn stringtable(&self) -> flatdata::RawData {
            flatdata::RawData::new(unsafe { self.stringtable.as_bytes() })
        }
    }

    impl ::std::fmt::Debug for Osm {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            f.debug_struct("Osm")
                .field("header", &self.header())
                .field("nodes", &self.nodes())
                .field("ways", &self.ways())
                .field("relations", &self.relations())
                .field("relation_members", &self.relation_members())
                .field("tags", &self.tags())
                .field("tags_index", &self.tags_index())
                .field("nodes_index", &self.nodes_index())
                .field("stringtable", &self.stringtable())
                .finish()
        }
    }

    impl flatdata::Archive for Osm {
        const NAME: &'static str = "Osm";
        const SCHEMA: &'static str = schema::osm::OSM;

        fn open(
            storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
        ) -> ::std::result::Result<Self, flatdata::ResourceStorageError> {
            storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

            let header = Self::read_resource(&*storage, "header", schema::osm::resources::HEADER)?;
            let nodes = Self::read_resource(&*storage, "nodes", schema::osm::resources::NODES)?;
            let ways = Self::read_resource(&*storage, "ways", schema::osm::resources::WAYS)?;
            let relations =
                Self::read_resource(&*storage, "relations", schema::osm::resources::RELATIONS)?;
            let relation_members = {
                let index_schema = &format!("index({})", schema::osm::resources::RELATION_MEMBERS);
                let index =
                    Self::read_resource(&*storage, "relation_members_index", &index_schema)?;
                let data = Self::read_resource(
                    &*storage,
                    "relation_members",
                    schema::osm::resources::RELATION_MEMBERS,
                )?;
                (index, data)
            };
            let tags = Self::read_resource(&*storage, "tags", schema::osm::resources::TAGS)?;
            let tags_index =
                Self::read_resource(&*storage, "tags_index", schema::osm::resources::TAGS_INDEX)?;
            let nodes_index = Self::read_resource(
                &*storage,
                "nodes_index",
                schema::osm::resources::NODES_INDEX,
            )?;
            let stringtable = Self::read_resource(
                &*storage,
                "stringtable",
                schema::osm::resources::STRINGTABLE,
            )?;

            Ok(Self {
                _storage: storage,
                header,
                nodes,
                ways,
                relations,
                relation_members,
                tags,
                tags_index,
                nodes_index,
                stringtable,
            })
        }
    }

    /// Builder for creating [`Osm`] archives.
    ///
    ///[`Osm`]: struct.Osm.html
    #[derive(Clone, Debug)]
    pub struct OsmBuilder {
        storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
    }

    impl OsmBuilder {
        #[inline]
        /// Stores [`header`] in the archive.
        ///
        /// [`header`]: struct.Osm.html#method.header
        pub fn set_header(
            &self,
            resource: <super::osm::Header as flatdata::Struct>::Item,
        ) -> ::std::io::Result<()> {
            let data = unsafe {
                ::std::slice::from_raw_parts(
                    resource.data,
                    <super::osm::Header as flatdata::Struct>::SIZE_IN_BYTES,
                )
            };
            self.storage
                .write("header", schema::osm::resources::HEADER, data)
        }

        #[inline]
        /// Stores [`nodes`] in the archive.
        ///
        /// [`nodes`]: struct.Osm.html#method.nodes
        pub fn set_nodes(
            &self,
            vector: &flatdata::ArrayView<super::osm::Node>,
        ) -> ::std::io::Result<()> {
            self.storage
                .write("nodes", schema::osm::resources::NODES, vector.as_ref())
        }

        /// Opens [`nodes`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`nodes`]: struct.Osm.html#method.nodes
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_nodes(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Node>> {
            flatdata::create_external_vector(&*self.storage, "nodes", schema::osm::resources::NODES)
        }

        #[inline]
        /// Stores [`ways`] in the archive.
        ///
        /// [`ways`]: struct.Osm.html#method.ways
        pub fn set_ways(
            &self,
            vector: &flatdata::ArrayView<super::osm::Way>,
        ) -> ::std::io::Result<()> {
            self.storage
                .write("ways", schema::osm::resources::WAYS, vector.as_ref())
        }

        /// Opens [`ways`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`ways`]: struct.Osm.html#method.ways
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_ways(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Way>> {
            flatdata::create_external_vector(&*self.storage, "ways", schema::osm::resources::WAYS)
        }

        #[inline]
        /// Stores [`relations`] in the archive.
        ///
        /// [`relations`]: struct.Osm.html#method.relations
        pub fn set_relations(
            &self,
            vector: &flatdata::ArrayView<super::osm::Relation>,
        ) -> ::std::io::Result<()> {
            self.storage.write(
                "relations",
                schema::osm::resources::RELATIONS,
                vector.as_ref(),
            )
        }

        /// Opens [`relations`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`relations`]: struct.Osm.html#method.relations
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_relations(
            &self,
        ) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Relation>> {
            flatdata::create_external_vector(
                &*self.storage,
                "relations",
                schema::osm::resources::RELATIONS,
            )
        }

        /// Opens [`relation_members`] in the archive for buffered writing.
        ///
        /// Elements can be added to the multivector until the [`MultiVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`relation_members`]: struct.Osm.html#method.relation_members
        /// [`MultiVector::close`]: flatdata/struct.MultiVector.html#method.close
        #[inline]
        pub fn start_relation_members(
            &self,
        ) -> ::std::io::Result<flatdata::MultiVector<RelationMembers>> {
            flatdata::create_multi_vector(
                &*self.storage,
                "relation_members",
                schema::osm::resources::RELATION_MEMBERS,
            )
        }

        #[inline]
        /// Stores [`tags`] in the archive.
        ///
        /// [`tags`]: struct.Osm.html#method.tags
        pub fn set_tags(
            &self,
            vector: &flatdata::ArrayView<super::osm::Tag>,
        ) -> ::std::io::Result<()> {
            self.storage
                .write("tags", schema::osm::resources::TAGS, vector.as_ref())
        }

        /// Opens [`tags`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`tags`]: struct.Osm.html#method.tags
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_tags(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Tag>> {
            flatdata::create_external_vector(&*self.storage, "tags", schema::osm::resources::TAGS)
        }

        #[inline]
        /// Stores [`tags_index`] in the archive.
        ///
        /// [`tags_index`]: struct.Osm.html#method.tags_index
        pub fn set_tags_index(
            &self,
            vector: &flatdata::ArrayView<super::osm::TagIndex>,
        ) -> ::std::io::Result<()> {
            self.storage.write(
                "tags_index",
                schema::osm::resources::TAGS_INDEX,
                vector.as_ref(),
            )
        }

        /// Opens [`tags_index`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`tags_index`]: struct.Osm.html#method.tags_index
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_tags_index(
            &self,
        ) -> ::std::io::Result<flatdata::ExternalVector<super::osm::TagIndex>> {
            flatdata::create_external_vector(
                &*self.storage,
                "tags_index",
                schema::osm::resources::TAGS_INDEX,
            )
        }

        #[inline]
        /// Stores [`nodes_index`] in the archive.
        ///
        /// [`nodes_index`]: struct.Osm.html#method.nodes_index
        pub fn set_nodes_index(
            &self,
            vector: &flatdata::ArrayView<super::osm::NodeIndex>,
        ) -> ::std::io::Result<()> {
            self.storage.write(
                "nodes_index",
                schema::osm::resources::NODES_INDEX,
                vector.as_ref(),
            )
        }

        /// Opens [`nodes_index`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`nodes_index`]: struct.Osm.html#method.nodes_index
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_nodes_index(
            &self,
        ) -> ::std::io::Result<flatdata::ExternalVector<super::osm::NodeIndex>> {
            flatdata::create_external_vector(
                &*self.storage,
                "nodes_index",
                schema::osm::resources::NODES_INDEX,
            )
        }

        /// Stores [`stringtable`] in the archive.
        ///
        /// [`stringtable`]: struct.Osm.html#method.stringtable
        #[inline]
        pub fn set_stringtable(&self, data: &[u8]) -> ::std::io::Result<()> {
            self.storage
                .write("stringtable", schema::osm::resources::STRINGTABLE, data)
        }
    }

    impl flatdata::ArchiveBuilder for OsmBuilder {
        const NAME: &'static str = "Osm";
        const SCHEMA: &'static str = schema::osm::OSM;

        fn new(
            storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
        ) -> Result<Self, flatdata::ResourceStorageError> {
            flatdata::create_archive::<Self>(&storage)?;
            Ok(Self { storage })
        }
    }
}

#[doc(hidden)]
pub mod _builtin {

    pub mod multivector {

        #[doc(hidden)]
        pub mod schema {
            pub mod structs {
                pub const INDEX_TYPE40: &str = r#""#;
            }
        }

        /// Builtin type to for MultiVector index
        ///
        /// ## Access pattern
        ///
        /// This structure is used as a template parameter in containers.
        /// It does not contain any data, instead it references
        ///
        /// * [`IndexType40Ref`] for the read-only access, and
        /// * [`IndexType40Mut`] for the mutable access
        ///
        /// to the `IndexType40` data.
        ///
        /// [`IndexType40Ref`]: struct.IndexType40Ref.html
        /// [`IndexType40Mut`]: struct.IndexType40Mut.html
        #[derive(Clone, Debug)]
        pub struct IndexType40 {}

        /// Read-only access to [`IndexType40`].
        ///
        /// [`IndexType40`]: struct.IndexType40.html
        #[derive(Clone, Copy)]
        pub struct IndexType40Ref<'a> {
            data: *const u8,
            _phantom: std::marker::PhantomData<&'a u8>,
        }

        impl<'a> flatdata::Struct<'a> for IndexType40 {
            const SCHEMA: &'static str = schema::structs::INDEX_TYPE40;
            const SIZE_IN_BYTES: usize = 5;
            const IS_OVERLAPPING_WITH_NEXT: bool = true;

            type Item = IndexType40Ref<'a>;

            #[inline]
            fn create(data: &'a [u8]) -> Self::Item {
                Self::Item {
                    data: data.as_ptr(),
                    _phantom: std::marker::PhantomData,
                }
            }

            type ItemMut = IndexType40Mut<'a>;

            #[inline]
            fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
                Self::ItemMut {
                    data: data.as_mut_ptr(),
                    _phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'a> IndexType40Ref<'a> {
            /// First element of the range [`range`].
            ///
            /// [`range`]: #method.range
            #[inline]
            pub fn value(&self) -> u64 {
                let value = flatdata_read_bytes!(u64, self.data, 0, 40);
                unsafe { std::mem::transmute::<u64, u64>(value) }
            }

            #[inline]
            pub fn range(&self) -> std::ops::Range<u64> {
                let start = flatdata_read_bytes!(u64, self.data, 0, 40);
                let end = flatdata_read_bytes!(u64, self.data, 0 + 5 * 8, 40);
                start..end
            }
        }

        impl<'a> std::fmt::Debug for IndexType40Ref<'a> {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.debug_struct("IndexType40")
                    .field("value", &self.value())
                    .finish()
            }
        }

        impl<'a> std::cmp::PartialEq for IndexType40Ref<'a> {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.value() == other.value()
            }
        }

        impl<'a> flatdata::Ref for IndexType40Ref<'a> {}

        /// Mutable access to [`IndexType40`].
        ///
        /// [`IndexType40`]: struct.IndexType40.html
        pub struct IndexType40Mut<'a> {
            data: *mut u8,
            _phantom: std::marker::PhantomData<&'a u8>,
        }

        impl<'a> IndexType40Mut<'a> {
            /// First element of the range [`range`].
            ///
            /// [`range`]: struct.IndexType40Ref.html#method.range
            #[inline]
            pub fn value(&self) -> u64 {
                let value = flatdata_read_bytes!(u64, self.data, 0, 40);
                unsafe { std::mem::transmute::<u64, u64>(value) }
            }

            #[allow(missing_docs)]
            #[inline]
            pub fn set_value(&mut self, value: u64) {
                let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 5) };
                flatdata_write_bytes!(u64; value, buffer, 0, 40)
            }

            /// Copies the data from `other` into this struct.
            #[inline]
            pub fn fill_from(&mut self, other: &IndexType40Ref) {
                self.set_value(other.value());
            }
        }

        impl<'a> std::fmt::Debug for IndexType40Mut<'a> {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                IndexType40Ref {
                    data: self.data,
                    _phantom: std::marker::PhantomData,
                }
                .fmt(f)
            }
        }

        impl<'a> flatdata::RefMut for IndexType40Mut<'a> {}

        impl<'a> flatdata::IndexStruct<'a> for IndexType40 {
            #[inline]
            fn range(data: Self::Item) -> std::ops::Range<usize> {
                let range = data.range();
                range.start as usize..range.end as usize
            }

            #[inline]
            fn set_index(mut data: Self::ItemMut, value: usize) {
                data.set_value(value as u64);
            }
        }
    }

    #[doc(hidden)]
    pub mod schema {
        pub mod structs {}
    }
}
